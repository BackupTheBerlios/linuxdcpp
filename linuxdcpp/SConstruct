###########################################################################
# 
#	This is the dcpp construction file. To use it type scons
#	Specify arguments with scons arg=value. Argumens:
#
#	debug=1:	Compile the program with debug information
#	release=1:	Compile the program with optimizations
#   atomic=0:	Disable atomic inc/dec in dc++ core. This is iseful if you 
#				don't have a processor supported by linux/atomic.h.
#
###########################################################################

import os, commands, string

def CheckPKGConfig(context): 
     context.Message('Checking for pkg-config... ') 
     ret = context.TryAction('pkg-config --version')[0] 
     context.Result(ret)
     return ret 
 
def CheckPKG(context, name): 
     context.Message('Checking for %s... ' % name) 
     ret = context.TryAction('pkg-config --exists \'%s\'' % name)[0] 
     context.Result(ret) 
     return ret 

def CheckDefine(context, symbol, header, library):
	testProg = """
		#include<%s>
		#ifndef %s
			#error
		#endif
		int main() {
			return 0;
		}
		""" % (header, symbol)
	context.Message('Checking for %s in %s... ' % (symbol, header))
	result = context.TryCompile(testProg, '.cc')
	context.Result(result)
	return result

def CheckCXXVersion(context, name, major, minor):
	context.Message('Checking for %s >= %d.%d...' % (name, major, minor))
	ret = commands.getoutput('%s -dumpversion' % name)

	retval = 0
	if ((string.atoi(ret[0]) == major and string.atoi(ret[2]) >= minor) 
	or (string.atoi(ret[0]) > major)):
		retval = 1
                
	context.Result(retval)
	return retval

# import enviroment variables from os
# this is to find headers and librarys and such
env = Environment(ENV=os.environ)

conf = Configure(env, custom_tests = {'CheckPKGConfig' : CheckPKGConfig, 
	'CheckDefine' : CheckDefine,
	'CheckPKG' : CheckPKG,
	'CheckCXXVersion' : CheckCXXVersion}) 

# This looks up the CXX enviroment variable so that people can specify
# what g++ to use on the command line (eg. prompt:> CXX=foo scons)
cxx = conf.env.Dictionary()['CXX']
if not conf.CheckCXXVersion(cxx, 3, 4):
	if WhereIs('g++-3.4') != None:
		print 'Found g++-3.4'
		cxx = 'g++-3.4'
	else:
	     print 'Compiler version check failed. g++ 3.4 or later is needed'
	     Exit(1)

conf.env.Replace(CXX = cxx)

if not conf.CheckPKGConfig(): 
     print 'pkg-config not found.' 
     Exit(1) 
 
if not conf.CheckPKG('gtk+-2.0 >= 2.4'): 
     print 'gtk+ >= 2.4 not found.' 
     Exit(1) 

if not conf.CheckPKG('gthread-2.0 >= 2.4'): 
     print 'gthread >= 2.4 not found.' 
     Exit(1) 

if not conf.CheckPKG('libglade-2.0 >= 2.4'): 
     print 'libglade >= 2.4 not found.' 
     Exit(1) 

if not conf.CheckHeader('time.h'):
	print 'Did not find the header time.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckHeader('signal.h'):
	print 'Did not find the header signal.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckHeader('unistd.h'):
	print 'Did not find the header unistd.h'
	print 'Can\'t live without it, sorry'
	Exit(1)
	
if not conf.CheckHeader('sys/poll.h'):
	print 'Did not find the header sys/poll.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckLibWithHeader('pthread', 'pthread.h', 'c'):
	print 'Did not find the pthread library, exiting!'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

if not conf.CheckLibWithHeader('z', 'zlib.h', 'c'):
	print 'Did not find the z library (gzip/z compression)'
	print 'Can\'t live without it, exiting'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

if not conf.CheckLibWithHeader('bz2', 'bzlib.h', 'c'):
	print 'Did not find the bz2 library (bz2 compression)'
	print 'Can\'t live without it, exiting'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

atomic = int(ARGUMENTS.get('atomic', 1))
if atomic:
	conf.env.Append(CXXFLAGS = '-DHAVE_ASM_ATOMIC_H')
	cpu = os.uname()[4]
	if cpu=='i386' or cpu=='i486' or cpu=='i586' or cpu=='i686':
		conf.env.Append(CXXFLAGS='-DTARGET_X86')
	elif cpu=='x86_64':
		conf.env.Append(CXXFLAGS='-DTARGET_X86_64')
	elif cpu=='alpha':
		conf.env.Append(CXXFLAGS='-DTARGET_ALPHA')
	elif cpu=='ppc':
		conf.env.Append(CXXFLAGS='-DTARGET_POWERPC')
	elif cpu=='sparc':
		conf.env.Append(CXXFLAGS='-DTARGET_SPARC')
	elif cpu=='arm':
		conf.env.Append(CXXFLAGS='-DTARGET_ARM')
	else:
		print 'Error: Unknown cpu architecture. Try compiling with atomic=0.'
		print 'Cpu string reported was \"' + cpu + '\".'
		Exit(1)

conf.env.Append(CXXFLAGS = '-D_GNU_SOURCE')
if not conf.CheckDefine('PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP', 'pthread.h', 'pthread'):
	print 'PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP is not defined in pthread.h'
	print 'This is required, exiting'
	print 'Note: This is a GNU specific thing as far as we know. So if'
	print 'your pthread implementation is not written by them this might'
	print 'explain why we can\'t find it.'
else:
	conf.env.Append(CXXFLAGS = '-DHAVE_DECL_PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP')

env = conf.Finish()
env.ParseConfig('pkg-config --cflags --libs libglade-2.0') 
env.ParseConfig('pkg-config --cflags --libs gthread-2.0') 
env.Append(CXXFLAGS = ['-I.', '-DENABLE_BINRELOC', '-D_FILE_OFFSET_BITS=64'])

debug = ARGUMENTS.get('debug', 0)
if int(debug):
	env.Append(CXXFLAGS = '-g')

release = ARGUMENTS.get('release', 0)
if int(release):
	env.Append(CXXFLAGS = '-O3')

objs = []
objs.append(SConscript('client/SConstruct', exports='env', build_dir='build/client', duplicate=0))
objs.append(SConscript('linux/SConstruct', exports='env', build_dir='build/gui', duplicate=0))
Default(env.Program('dcpp', objs))
