###########################################################################
# 
#	This is the ldcpp construction file. To use it type scons
#	Specify arguments with scons arg=value. Argumens:
#
#      debug=1:                Compile the program with debug information
#      release=1:              Compile the program with optimizations
#      PREFIX="path":          Compile the program with PREFIX as the root
#                              for installation.
#                              eg. PREFIX=/usr/local -> ldcpp goes into
#                              PREFIX/bin/ and other files into PREFIX/lib/
#                              and PREFIX/share/
#      BINDIR="path":          Place the program (ldcpp executable) in BINDIR
#                              defaluts to PREFIX/bin/
#      LIBDIR="path":          Place the glade and pixmap files under LIBDIR
#                              defaults to PREFIX/lib/
#      DOCDIR="path":          Place the program docs into DOCDIR
#                              defaults to PREFIX/share/doc/
#      FAKE_ROOT="path":       Make scons install ldcpp under a fake root
#                              (for gentoo ebuilds)
#
###########################################################################

import os, commands, string

def CheckPKGConfig(context): 
     context.Message('Checking for pkg-config... ') 
     ret = context.TryAction('pkg-config --version')[0] 
     context.Result(ret)
     return ret 
 
def CheckPKG(context, name): 
     context.Message('Checking for %s... ' % name) 
     ret = context.TryAction('pkg-config --exists \'%s\'' % name)[0] 
     context.Result(ret) 
     return ret 

def CheckDefine(context, symbol, header, library):
	testProg = """
		#include<%s>
		#ifndef %s
			#error
		#endif
		int main() {
			return 0;
		}
		""" % (header, symbol)
	context.Message('Checking for %s in %s... ' % (symbol, header))
	result = context.TryCompile(testProg, '.cc')
	context.Result(result)
	return result

def CheckCXXVersion(context, name, major, minor):
	context.Message('Checking for %s >= %d.%d...' % (name, major, minor))
	ret = commands.getoutput('%s -dumpversion' % name)

	retval = 0
	if ((string.atoi(ret[0]) == major and string.atoi(ret[2]) >= minor) 
	or (string.atoi(ret[0]) > major)):
		retval = 1
                
	context.Result(retval)
	return retval

# import enviroment variables from os
# this is to find headers and librarys and such
env = Environment(ENV=os.environ)

conf = Configure(env, custom_tests = {'CheckPKGConfig' : CheckPKGConfig, 
	'CheckDefine' : CheckDefine,
	'CheckPKG' : CheckPKG,
	'CheckCXXVersion' : CheckCXXVersion}) 

# This looks up the CXX enviroment variable so that people can specify
# what g++ to use on the command line (eg. prompt:> CXX=foo scons)
cxx = conf.env.Dictionary()['CXX']
if not conf.CheckCXXVersion(cxx, 3, 4):
	if WhereIs('g++-3.4') != None:
		print 'Found g++-3.4'
		cxx = 'g++-3.4'
	else:
	     print 'Compiler version check failed. g++ 3.4 or later is needed'
	     Exit(1)

conf.env.Replace(CXX = cxx)

if not conf.CheckPKGConfig(): 
     print 'pkg-config not found.' 
     Exit(1) 
 
if not conf.CheckPKG('gtk+-2.0 >= 2.6'): 
     print 'gtk+ >= 2.6 not found.' 
     Exit(1) 

if not conf.CheckPKG('gthread-2.0 >= 2.4'): 
     print 'gthread >= 2.4 not found.' 
     Exit(1) 

if not conf.CheckPKG('libglade-2.0 >= 2.4'): 
     print 'libglade >= 2.4 not found.' 
     Exit(1) 

if not conf.CheckHeader('time.h'):
	print 'Did not find the header time.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckHeader('signal.h'):
	print 'Did not find the header signal.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckHeader('unistd.h'):
	print 'Did not find the header unistd.h'
	print 'Can\'t live without it, sorry'
	Exit(1)
	
if not conf.CheckHeader('sys/poll.h'):
	print 'Did not find the header sys/poll.h'
	print 'Can\'t live without it, sorry'
	Exit(1)

if not conf.CheckLibWithHeader('pthread', 'pthread.h', 'c'):
	print 'Did not find the pthread library, exiting!'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

if not conf.CheckLibWithHeader('z', 'zlib.h', 'c'):
	print 'Did not find the z library (gzip/z compression)'
	print 'Can\'t live without it, exiting'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

if not conf.CheckLibWithHeader('bz2', 'bzlib.h', 'c'):
	print 'Did not find the bz2 library (bz2 compression)'
	print 'Can\'t live without it, exiting'
	print 'Note: You might have the lib but not the headers'
	Exit(1)

detected = 1
cpu = os.uname()[4]
if cpu=='i386' or cpu=='i486' or cpu=='i586' or cpu=='i686':
	conf.env.Append(CXXFLAGS='-DTARGET_X86')
elif cpu=='x86_64':
	conf.env.Append(CXXFLAGS='-DTARGET_X86_64')
elif cpu=='alpha':
	conf.env.Append(CXXFLAGS='-DTARGET_ALPHA')
elif cpu=='ppc':
	conf.env.Append(CXXFLAGS='-DTARGET_POWERPC')
elif cpu=='sparc':
#	conf.env.Append(CXXFLAGS='-DTARGET_SPARC')
	print 'Warning: Atomic operations for sparc not avaliable. Disabling.'
	detected = 0
elif cpu=='arm':
	conf.env.Append(CXXFLAGS='-DTARGET_ARM')
elif cpu=='mips':
	conf.env.Append(CXXFLAGS='-DTARGET_MIPS')
elif cpu=='ia64':
#	conf.env.Append(CXXFLAGS='-DTARGET_IA64')
	print 'Warning: Atomic operations for ia64 not avaliable. Disabling.'
	detected = 0
else:
	print 'Warning: Unknown cpu architecture. Disabling atomic operations.'
	print 'Cpu string reported was \"' + cpu + '\".'
	detected = 0

if detected:
	conf.env.Append(CXXFLAGS = '-DHAVE_ASM_ATOMIC_H')

conf.env.Append(CXXFLAGS = '-D_GNU_SOURCE')
if not conf.CheckDefine('PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP', 'pthread.h', 'pthread'):
	print 'PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP is not defined in pthread.h'
	print 'This is required, exiting'
	print 'Note: This is a GNU specific thing as far as we know. So if'
	print 'your pthread implementation is not written by them this might'
	print 'explain why we can\'t find it.'
	Exit(1)
else:
	conf.env.Append(CXXFLAGS = '-DHAVE_DECL_PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP')

env = conf.Finish()
env.ParseConfig('pkg-config --cflags --libs libglade-2.0') 
env.ParseConfig('pkg-config --cflags --libs gthread-2.0') 
env.Append(CXXFLAGS = ['-I.', '-DENABLE_BINRELOC', '-D_FILE_OFFSET_BITS=64'])

debug = ARGUMENTS.get('debug', 0)
if int(debug):
	env.Append(CXXFLAGS = '-g -ggdb -D_DEBUG')
	env.Append(LDFLAGS = '-g -ggdb')

release = ARGUMENTS.get('release', 0)
if int(release):
	env.Append(CXXFLAGS = '-O3')

prefix = ARGUMENTS.get('PREFIX','')
root = ARGUMENTS.get('FAKE_ROOT','')
_dir = ''
bindir = ARGUMENTS.get('BINDIR', prefix + '/bin')
libdir = ARGUMENTS.get('LIBDIR', prefix + '/lib')
docdir = ARGUMENTS.get('DOCDIR', prefix + '/share/doc')
if str(prefix):
	env.Append(CXXFLAGS = '-D_PREFIX=\'\"' + prefix + '\"\'')
	env.Append(CXXFLAGS = '-D_LIBDIR=\'\"' + libdir + '\"\'')
_dir = root

objs = []
objs.append(SConscript('client/SConstruct', exports='env', build_dir='build/client', duplicate=0))
objs.append(SConscript('linux/SConstruct', exports='env', build_dir='build/gui', duplicate=0))
Default(env.Program('ldcpp', objs))

glade_files=['glade/favoritehubs.glade','glade/hash.glade',
	'glade/mainwindow.glade','glade/publichubs.glade',
	'glade/settingsdialog.glade','glade/downloadqueue.glade',
	'glade/finishedtransfers.glade','glade/hub.glade',
	'glade/privatemessage.glade','glade/search.glade',
	'glade/sharebrowser.glade']
pixmap_files=['pixmaps/dc++-fw.png','pixmaps/dc++.png',
	'pixmaps/favhubs.png','pixmaps/FinishedUL.png',
	'pixmaps/normal-fw.png','pixmaps/normal.png',
	'pixmaps/queue.png','pixmaps/settings.png',
	'pixmaps/dc++-fw-op.png','pixmaps/dc++-op.png',
	'pixmaps/download.png','pixmaps/FinishedDL.png',
	'pixmaps/normal-fw-op.png','pixmaps/normal-op.png',
	'pixmaps/publichubs.png','pixmaps/search.png',
	'pixmaps/upload.png']

text_files=['Changelog.txt','Credits.txt','License.txt','Readme.txt']

env.Install(dir = _dir + libdir + '/ldcpp/glade', source = glade_files)
env.Install(dir = _dir + libdir + '/ldcpp/pixmaps', source = pixmap_files)
env.Install(dir = _dir + docdir + '/ldcpp', source = text_files)
env.Install(dir = _dir + bindir, source = 'ldcpp')

env.Alias('install',[_dir + libdir + '/ldcpp/glade',
	_dir + libdir + '/ldcpp/pixmaps',
	_dir + docdir + '/ldcpp',
	_dir + bindir])
